[{
    "title": "21. Merge Two Sorted Lists",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/merge-two-sorted-lists/\nYou are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nIdea: Merge two lists into a single list\nSolution:  class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* head = nullptr, *tail = nullptr; int val; while(list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { val = list1-\u0026gt;val; list1 = list1-\u0026gt;next; } else { val = list2-\u0026gt;val; list2 = list2-\u0026gt;next; } insertNode(head, tail, val); } while (list1) { insertNode(head, tail, list1-\u0026gt;val); list1 = list1-\u0026gt;next; } while (list2) { insertNode(head, tail, list2-\u0026gt;val); list2 = list2-\u0026gt;next; } return head; } void insertNode(ListNode * \u0026amp;head, ListNode * \u0026amp;tail, const int val) { ListNode* insert = new ListNode(val); if (head == nullptr) { head = tail = insert; } else { tail-\u0026gt;next = insert; tail = tail-\u0026gt;next; } } }; Complexity Analysis:  Time O(N + M) where N is size of list 1 and M is size of list2\nMemory O(N + M) where N is size of list 1 and M is size of list2\n",
    "ref": "/hugo/blog/merge-sorted-lists/"
  },{
    "title": "20. Valid Parentheses",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/valid-parentheses/\nGiven a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\nIdea: If we see a closing parenthese, that means that the most recently seen opening parenthese must be it\u0026rsquo;s complement.\nIf not, we know the string does not have valid parantheses.\nTo do this, we use a stack and scan over the string. If the char is a opening paren, add it to the stack. If its a closing paren, see if the most recent open paren is it\u0026rsquo;s complement. If its not, return false. Otherwise pop the top of the stack.\nAt the end, we check the size of the stack. If its empty that means every opening paren found its complement and thus the string is valid.\nSolution:  class Solution { public: bool isValid(string s) { deque\u0026lt;char\u0026gt; deque; for(auto \u0026amp;current : s) { if (isOpenBracket(current)) { deque.push_back(current); } else { if (deque.empty() || !isComplement(current, deque)) { return false; } } } return deque.empty(); } bool isOpenBracket(const char \u0026amp; c) { return (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;); } bool isComplement(const char \u0026amp; closed, deque\u0026lt;char\u0026gt; \u0026amp; deque) { const char open = deque.back(); deque.pop_back(); if (open == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; closed != \u0026#39;)\u0026#39;) { return false; } else if (open == \u0026#39;[\u0026#39; \u0026amp;\u0026amp; closed != \u0026#39;]\u0026#39;) { return false; } else if (open == \u0026#39;{\u0026#39; \u0026amp;\u0026amp; closed != \u0026#39;}\u0026#39;) { return false; } return true; } }; Complexity Analysis:  Time O(N) to loop over the string\nConstant time to check if char is open paren or closed paren (and if closed that it has a complement)\nO(N) + c = O(N)\nMemory O(N) in the worst case. Ex (\u0026quot;((((\u0026quot;)\n",
    "ref": "/hugo/blog/valid-parentheses/"
  },{
    "title": "1. Two Sum",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/two-sum/\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nIdea: Here we construct a lookup map where the key is the number and the value is the index.\nThen for search, we compute the corresponding number using (b = target - a).\nIf this result is present in lookup, we can return the current index and index in lookup map.\nSolution: class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; valueToIndex; vector\u0026lt;int\u0026gt; res; for (int i = 0; i \u0026lt; nums.size(); ++i) { valueToIndex[nums[i]] = i; } for(int i = 0; i \u0026lt; nums.size(); ++i) { auto match = valueToIndex.find((target - nums[i])); if (match != valueToIndex.end() \u0026amp;\u0026amp; i != match-\u0026gt;second) { res = {i, match-\u0026gt;second}; break; } } return res; } }; Complexity Analysis:  Time Creating the lookup map is an O(N) operation.\nSearching the pair that sums to target is worst case an O(N) operation.\nO(N) + O(N) = 0(N)\nMemory Lookup map is O(N)\nResult vector is constant space\nO(N) + c = O(N)\n",
    "ref": "/hugo/blog/two-sum/"
  },{
    "title": "79. Word Search",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/word-search/\nProblem Statement:\rGiven an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n Examples\r\r1:\r \rInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCCED\u0026#34;\rOutput: true Idea:\r\rHere what we do is a breadth first search, but also marking our path as we going along. We keep progressing so long as the current spot in the grid is equal to the current letter in the target word. When we visit a cell, we mark it as visited and recursively search the neighbors. When we return from this, we set the cell back to the orignal value.\nSolution:\r\r class Solution { public:    bool dfs(int row, int col, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string \u0026amp; target, int index) {  if(index \u0026gt;= target.size()) {  return true;  }   if(row \u0026lt; 0 || col \u0026lt; 0 || row \u0026gt;= board.size() || col \u0026gt;= board.front().size() || board[row][col] != target[index]) {  return false;  }   board[row][col] = \u0026#39;$\u0026#39;;   if(dfs(row - 1, col, board, target, index + 1) ||  dfs(row + 1, col, board, target, index + 1) ||  dfs(row, col + 1, board, target, index + 1) ||  dfs(row, col - 1, board, target, index + 1)  ) {  return true;  }   board[row][col] = target[index];  return false;    }   bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) {  for(int i = 0; i \u0026lt; board.size(); ++i) {  for(int j = 0; j \u0026lt; board.front().size(); ++j) {  if(dfs(i, j, board, word, 0)) {  return true;  }  }  }   return false;  } }; Complexity Analysis:\r\rTime\rWe look at every cell in the board, and looking at every cell is order O(M * N) where M and N are the dimensions of the grid.\nAnd for each cell, we could potentially recurse L times where L is the length of the string.\nTherefore the overall time complexity is (M * N * L)\nMemory\rO(L) stack space for recursive calls.\n",
    "ref": "/hugo/blog/word-search/"
  },{
    "title": "55. Jump Game",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/jump-game/\nProblem Statement:\r Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.\nExamples\r\rExample 1\rInput: nums = [2,3,1,1,4]\rOutput: true\rExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\rExample 2\rInput: nums = [3,2,1,0,4]\rOutput: false\rExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\rIdea:\r\rHere we can keep track of the left most index. If the current element can get at least to the left most index, it becomes the left most index. Therefore if we go right to left, if at the end the left most index is 0, we know we can jump to the end.\nGreedily update the left most index.\nSolution:\r\r class Solution { public:  bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  int leftMostIndex = nums.size() - 1;   for(int i = nums.size() - 1; i \u0026gt;= 0; --i) {  // if we can at least reach the left most index, make i the left most index.  if(i + nums[i] \u0026gt;= leftMostIndex) {  leftMostIndex = i;  }  }   // if left most index ends at zero, we can jump to the end.  return leftMostIndex == 0;  } }; Complexity Analysis:\r\rTime\rO(N) time. It is a one time linear pass over the input array.\nMemory\rO(1) memory.\nSide Note: Original DP Implementation I went with\r\r class Solution { public:  bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) {  if(nums.empty()) {  return false;  }   vector\u0026lt;int\u0026gt; dp;  dp.resize(nums.size(), 0);  dp[nums.size() - 1] = 1;    // start at the second to last, we can always reach the last element  for(int i = nums.size() - 2; i \u0026gt;= 0; --i) {   int num_to_check = nums[i];  int cur_offset = 1;   while( ((cur_offset + i) \u0026lt; nums.size()) \u0026amp;\u0026amp; (num_to_check \u0026gt; 0) ) {  if(dp[i + cur_offset] == 1) {  dp[i] = 1;  break;  }  cur_offset += 1;  num_to_check -= 1;  }  }    return dp[0];  } }; Time\rO(N^2) time.\nMemory\rO(N) memory.\n",
    "ref": "/hugo/blog/jump_game/"
  },{
    "title": "226. Invert Binary Tree",
    "date": "",
    "description": "",
    "body": "Problem Statement:\r Invert a binary tree.\nIdea:\r\rHere we just use a simple recursive solution. Just swap your children pointers, then call recursively on the children. Eventually everynode will swap the children pointers, and the tree will be inverted.\nSolution:\r\r\rclass Solution {\rpublic:\rTreeNode* invertTree(TreeNode* root) {\rswapNodes(root);\rreturn root;\r}\rvoid swapNodes(TreeNode *root) {\rif (!root) return;\rstd::swap(root-\u0026gt;left, root-\u0026gt;right);\rswapNodes(root-\u0026gt;left);\rswapNodes(root-\u0026gt;right);\r}\r}; Complexity Analysis:\r\rTime\rO(H) where H is the height of the tree.\nMemory\rO(H) where H is the height of the tree, memory used in the form of stack frames from recursive calls.\n",
    "ref": "/hugo/blog/invert_tree/"
  },{
    "title": "191. Number of 1 Bits",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/number-of-1-bits/\nProblem Statement:\r Return the number of bits set to 1 in a 4 byte integer.\nIdea:\r\rThe idea here is to use a clever trick, created by Brian Kernighan. Instead of doing a naive O(N) traversal over the bits of the input integer, this algorthim works by removing the rightmost 1 bit iteratively until the number is zero.\nTherefore, the number of iterations the algorithm takes to converge depends on the number of bits set to 1 on the input integer.\nFor example, the number 5 has 2 bits set to 1. ( 0101 ). Kernighan\u0026rsquo;s algorithm only takes 2 iterations here.\nThe idea is showcases in the code below. It uses clever bit manipulation to find the right most 1 bit and remove it.\nSolution:\r\r  int count_one_bits(int x) {  int count = 0;   while(x != 0) {   // Update count.  count += 1;   // Remove the rightmost one bit.  x \u0026amp;= (x-1);  }   return count; } Complexity Analysis:\r\rTime\rO(N) time in the worst case that all bits on the input are zero. Faster on the common case where this isn\u0026rsquo;t true.\nMemory\rO(1) memory.\n",
    "ref": "/hugo/blog/count_one_bits/"
  },{
    "title": "994. Rotting Oranges",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/rotting-oranges/\nProblem Statement:\r In a given grid, each cell can have one of three values:\nthe value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.\nExamples\r\r1:\r \r Input: [[2,1,1],[1,1,0],[0,1,1]] Output: 4 2:\r Input: [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. 3:\r Input: [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Idea:\r\rSolution:\r\r class Solution { public:  int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) {   } }; Complexity Analysis:\r\rTime\rMemory\r",
    "ref": "/hugo/blog/rotting-oranges/"
  },{
    "title": "200. Number of Islands",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/number-of-islands/solution/\nProblem Statement:\r Given a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExamples\r\r1:\r Input: grid = [  [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output: 1 2:\r Input: grid = [  [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],  [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output: 3 Idea:\r\rThis question is analogous to the problem of connected components in an undirected graph.\nHere I used recursion for a depth first search.\nSolution:\r\rDFS:\r void dfs(int i, int j, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {  // exit if search exhuasted  if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= grid.size() || j \u0026gt;= grid[0].size() || grid[i][j] != \u0026#39;1\u0026#39;)  return;   grid[i][j] = \u0026#39;0\u0026#39;;  dfs(i - 1, j, grid);  dfs(i, j - 1, grid);  dfs(i + 1, j, grid);  dfs(i, j + 1, grid);  }   int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {  for(unsigned i = 0; i \u0026lt; grid.size(); ++i) {  for(unsigned j = 0; j \u0026lt; grid[0].size(); ++j) {  if(grid[i][j] == \u0026#39;1\u0026#39;) {  dfs(i, j, grid);  ++count;  }  }  }   return count;  } Union Find:\r  int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {   } Complexity Analysis:\r\rTime\rWorst case is O(M X N) where M and N are the dimensions of the input grid.\nMemory\rHere we reuse the input grid which is good. However since it is recursive, its possible to use O(MxN) memory in the case where the grid is all ones.\n",
    "ref": "/hugo/blog/number-of-islands/"
  },{
    "title": "Disjoint Sets",
    "date": "",
    "description": "",
    "body": "Disjoint-set operations\r A disjoint-set data structure maintains a collection S = {s_1, s_2, \u0026hellip; s_k} disjoint sets. We identify each set by a representative.\n Union Pseudocode: \r\r  function Union(x, y) is  xRoot := Find(x)  yRoot := Find(y)   if xRoot = yRoot then  // x and y are already in the same set  return   // x and y are not in same set, so we merge them  if xRoot.size \u0026lt; yRoot.size then  xRoot, yRoot := yRoot, xRoot // swap xRoot and yRoot   // merge yRoot into xRoot  yRoot.parent := xRoot  xRoot.size := xRoot.size + yRoot.size Set-Union Data Structures:\r\rTodo\nConnected Components DFS Solution:\r\r Connected_Components(Graph G):  for v in vertex:  flag[v] = -1  count = 0   for v in vertex:  if flag[v] == -1 // unvisited  dfs(v, flag)  count++  DFS(int v, int flag)  flag[v] = 1  for each adjacent node of v  if flag[u] == - // unvisited  DFS(u, flag) Idea behind connected components DFS.\r\rEvery node is initially marked as -1 meaning not visited.\nThe main loop will go over all verticies, calling a DFS function if that vertex is unvisited ( == -1).\nIf unvisited, a DFS function will be called. This will recursively mark the neighbors of vertex v as visited, and then have then visit their neighbors and so on.\nThis means that when all neighbors have been visited, the DFS call will return. Hence we increment the count.\nAt the end, will will know the number of connected components in the graph.\nComplexity Analysis:\r\r",
    "ref": "/hugo/blog/disjoint-sets/"
  },{
    "title": "129. Sum Root to Leaf Numbers",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/sum-root-to-leaf-numbers/\nProblem Statement:  Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\nAn example is the root-to-leaf path 1-\u0026gt;2-\u0026gt;3 which represents the number 123.\nFind the total sum of all root-to-leaf numbers.\nNote: A leaf is a node with no children.\nExamples  1: Input: [1,2,3]  1  / \\  2 3 Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. 2: Input: [4,9,0,5,1]  4  / \\  9 0  / \\ 5 1 Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Idea:  The idea is traverse our tree, using any tree traversal algorighm. I choose dfs, and also I directly change the values of our tree.\n If we reach non-existing node (None), we just return back. If we reached leaf, that is it do not have any children, return value of this node. Update values for left and right children if they exist. Finally, call function recursively for left and right children and return sum of results for left and right.  Solution:  class Solution { public:   void findPath(TreeNode* root, string \u0026amp;path, int \u0026amp;total) {  if(root == nullptr) return;  path += std::to_string(root-\u0026gt;val);   if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) {  total += stoi(path);  }  findPath(root-\u0026gt;left, path, total);  findPath(root-\u0026gt;right, path, total);   path.pop_back();  }   int sumNumbers(TreeNode* root) {  string path;  int total = 0;  findPath(root, path, total);   return total;  } }; TODO: Look at Morris Preorder Traversal.\nComplexity Analysis:  Time O(N). We look at each node once. Memory Here it is O(H) where H is the height of the binary tree. This will be where most recursive calls are made/where path string will be largest. ",
    "ref": "/hugo/blog/sum-root-to-leaf-numbers/"
  },{
    "title": "257. Binary Tree Paths",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/binary-tree-paths/\nProblem Statement:  Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExamples  1: Input:   1  / \\ 2 3  \\  5  Output: [\u0026#34;1-\u0026gt;2-\u0026gt;5\u0026#34;, \u0026#34;1-\u0026gt;3\u0026#34;]  Explanation: All root-to-leaf paths are: 1-\u0026gt;2-\u0026gt;5, 1-\u0026gt;3 Idea:  The most intuitive way is to use a recursion here. One is going through the tree by considering at each step the node itself and its children. If node is not a leaf, one extends the current path by a node value and calls recursively the path construction for its children. If node is a leaf, one closes the current path and adds it into the list of paths.\nSolution:  class Solution { public:   void findPath(TreeNode * root, vector\u0026lt;string\u0026gt; \u0026amp;paths, vector\u0026lt;int\u0026gt; \u0026amp;path) {  if(root == nullptr) return;  path.push_back(root-\u0026gt;val);   if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) {  string res = std::to_string(path[0]);  for(unsigned i = 1; i \u0026lt; path.size(); ++i) {  res += \u0026#34;-\u0026gt;\u0026#34; + std::to_string(path[i]);  }  paths.push_back(res);  }  findPath(root-\u0026gt;left, paths, path);  findPath(root-\u0026gt;right, paths, path);  path.pop_back();  }    vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) {  vector\u0026lt;string\u0026gt; paths;  vector\u0026lt;int\u0026gt; path;  findPath(root, paths, path);  return paths;  } }; Complexity Analysis:  Time O(N). We visit each node once. Memory O(N) for the vector of ints reprening the current path. Could be worst case O(N) with unbalanced tree. Expect O(logN) with balanced tree. ",
    "ref": "/hugo/blog/binary-tree-paths/"
  },{
    "title": "814. Binary Tree Pruning",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/binary-tree-pruning/\nProblem Statement:  We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\nExamples  1:   2:   3:   Idea:  The idea here is to make a recursive helper function that will tell us if a given subtree contains a zero. We call this function on the root, and it will be recursively called on the subtrees. If we find at any point a given subtree contains a zero, that branch is effectively removed by setting the subtree to nullptr. At the end, all subtrees that contain zero will be removed.\nSolution:   class Solution {  public:   bool has_one(TreeNode* root) {  if(root == nullptr) return false;  bool left = has_one(root-\u0026gt;left);  bool right = has_one(root-\u0026gt;right);  if(!left) root-\u0026gt;left = nullptr;  if(!right) root-\u0026gt;right = nullptr;  return left || right || root-\u0026gt;val == 1;  }   TreeNode* pruneTree(TreeNode* root) {  return has_one(root) ? root: nullptr;  }  }; Complexity Analysis:  Time Time Complexity here is O(N). We process each node once in the process. Memory Here space compexity is O(H) where H is the height of our tree. In the worst case, we expect order O(N) for a totally unbalanced tree. Expect O(logN) if working with balanced tree.",
    "ref": "/hugo/blog/binary-tree-pruning/"
  },{
    "title": "235. Lowest Common Ancestor of a Binary Search Tree",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nProblem Statement:  Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: ‚ÄúThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).‚Äù\nExample:  Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Idea:  My approach was recursive in nature, but prunes the tree and can achieve O(log N) time and space complexity (call stack) if used on a balanced tree.\nThe idea is to check if p and q are in different subtrees. If p is on the left and q is on the right, or vice versa, this means that we have found the solution. The first node in which p and q are in different trees is by definition their least common ancestor.\nTherefore, we use the sorted nature of the BST to go left or right if p and q are on the same side of the tree. If they aren\u0026rsquo;t on the same side, we\u0026rsquo;ve found the solution.\nIf we never find such a node, return nullptr;\nAs a side note, I chose to make p and q global to avoid passing them along the call stack in the recursive function.\nSolution:  class Solution { public:  int PVAL, QVAL;   TreeNode* findLCA(TreeNode* root) {   if(!root) return nullptr;   if((PVAL \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; QVAL \u0026lt;= root-\u0026gt;val) || (PVAL \u0026lt;= root-\u0026gt;val \u0026amp;\u0026amp; QVAL \u0026gt;= root-\u0026gt;val)) {  return root;  }   if(PVAL \u0026gt; root-\u0026gt;val) {  return findLCA(root-\u0026gt;right);  } else {  return findLCA(root-\u0026gt;left);  }   }   TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {  PVAL = p-\u0026gt;val;  QVAL = q-\u0026gt;val;  return findLCA(root);  } }; Complexity Analysis:  Time Here worst case is O(N) if our tree is an unbalanced stick where p/q happen to be very far from the root.\nWith idea situations, search space is cut in half each time provided the tree is balanced so we see O(logN) time complexity.\nComplexity is directly related to the ability so find the solution.\nMemory Memory usage is directly related to the number of stack frames for recursive search. O(N) unbalanced stick with p \u0026amp; q far from root. O(logN) with balanced tree.\n",
    "ref": "/hugo/blog/lowest-common-ancestor-bst/"
  },{
    "title": "100. Same Tree",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/same-tree/\nGiven two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nIdea:\rRecursively check each node in each tree. If both are null, we\u0026rsquo;ve gone off the end so return true If one is null and the other isn\u0026rsquo;t, there is a difference. If one has a val that isn\u0026rsquo;t equal to the other, there is a difference. Otherwise recursively call on the subtrees.\nSolution:\rclass solution { public:  bool issametree(treenode* p, treenode* q) {  if(!p and !q) return true;  if(!p or !q) return false;  if(p-\u0026gt;val != q-\u0026gt;val) return false;  return issametree(p-\u0026gt;left, q-\u0026gt;left) \u0026amp;\u0026amp; issametree(p-\u0026gt;right, q-\u0026gt;right);  } }; Complexity Analysis:\r\rTime\rO(N). Each node in each tree compared.\rMemory\rO(N). Worst case stack usage if trees are unbalanced.",
    "ref": "/hugo/blog/same-tree/"
  },{
    "title": "113. Path Sum II",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/path-sum-ii/\nProblem Statement:  Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children.\nExample:  Given the below binary tree and sum = 22,  5  / \\  4 8  / / \\  11 13 4  / \\ / \\ 7 2 5 1 Return:\n[  [5,4,11,2],  [5,8,4,5] ] Idea:  We can solve this using a recursive depth first search approach. First we set up a helper function that will help us recursively store the path and add it if a matching sum is found. As base cases, our recursive function will return if the node is null, or a leaf node matching the sum has been found.\nOtherwise, the function is called recursively on the left and right subtrees.\nAt the end, the results list with all such paths is returned.\nSolution:   class Solution {  public:  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int sum) {  vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; paths;  vector\u0026lt;int\u0026gt; path;  findPaths(root, sum, path, paths);  return paths;  }  private:  void findPaths(TreeNode* node, int sum, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; paths) {  if (!node) return;  path.push_back(node -\u0026gt; val);  if (!(node -\u0026gt; left) \u0026amp;\u0026amp; !(node -\u0026gt; right) \u0026amp;\u0026amp; sum == node -\u0026gt; val)  paths.push_back(path);  findPaths(node -\u0026gt; left, sum - node -\u0026gt; val, path, paths);  findPaths(node -\u0026gt; right, sum - node -\u0026gt; val, path, paths);  path.pop_back();  }  }; Complexity Analysis:  Time O(N^2) where N is the number of nodes in a tree. In the worst case, we could have a complete binary tree and if that is the case, then there would be N/2 leafs. For every leaf, we perform a potential O(N) operation of copying over the pathNodes nodes to a new list to be added to the final pathsList. Hence, the complexity in the worst case could be O(N^2). Memory O(N). From Leetcode discussion - The space complexity, like many other problems is debatable here. I personally choose not to consider the space occupied by the output in the space complexity. So, all the new lists that we create for the paths are actually a part of the output and hence, don't count towards the final space complexity. The only additional space that we use is the pathNodes list to keep track of nodes along a branch. We could include the space occupied by the new lists (and hence the output) in the space complexity and in that case the space would be O(N^2) There\u0026rsquo;s a great answer on Stack Overflow about whether to consider input and output space in the space complexity or not. I prefer not to include them.\n",
    "ref": "/hugo/blog/path-sum-ii/"
  },{
    "title": "About",
    "date": "",
    "description": "",
    "body": "Todo\n",
    "ref": "/hugo/about/"
  },{
    "title": "Emoji Support",
    "date": "",
    "description": "Guide to emoji usage in Hugo",
    "body": "Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site‚Äôs configuration and then you can type emoji shorthand codes directly in content files; e.g.\nüôà :see_no_evil: üôâ :hear_no_evil: üôä :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }",
    "ref": "/hugo/blog/emoji-support/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/hugo/contact/"
  }]
