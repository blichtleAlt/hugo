[{
    "title": "Count_one_bits",
    "date": "",
    "description": "",
    "body": "TODO: Link\nProblem Statement:\r Examples\r\r1:\r \r2:\r \r3:\r \rIdea:\r\rSolution:\r\rComplexity Analysis:\r\rTime\rMemory\r",
    "ref": "/hugo/blog/count_one_bits/"
  },{
    "title": "994. Rotting Oranges",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/rotting-oranges/\nProblem Statement:\r In a given grid, each cell can have one of three values:\nthe value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.\nExamples\r\r1:\r \rInput: [[2,1,1],[1,1,0],[0,1,1]]\rOutput: 4\r2:\rInput: [[2,1,1],[0,1,1],[1,0,1]]\rOutput: -1\rExplanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\r3:\rInput: [[0,2]]\rOutput: 0\rExplanation: Since there are already no fresh oranges at minute 0, the answer is just 0.\rIdea:\r\rSolution:\r\rclass Solution {\rpublic:\rint orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) {\r}\r};\rComplexity Analysis:\r\rTime\rMemory\r",
    "ref": "/hugo/blog/rotting-oranges/"
  },{
    "title": "200. Number of Islands",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/number-of-islands/solution/\nProblem Statement:\r Given a 2d grid map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExamples\r\r1:\rInput: grid = [\r[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;]\r]\rOutput: 1\r2:\rInput: grid = [\r[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;],\r[\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;]\r]\rOutput: 3\rIdea:\r\rThis question is analogous to the problem of connected components in an undirected graph.\nHere I used recursion for a depth first search.\nSolution:\r\rDFS:\rvoid dfs(int i, int j, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\r// exit if search exhuasted\r if(i \u0026lt; 0 || j \u0026lt; 0 || i \u0026gt;= grid.size() || j \u0026gt;= grid[0].size() || grid[i][j] != \u0026#39;1\u0026#39;)\rreturn;\rgrid[i][j] = \u0026#39;0\u0026#39;;\rdfs(i - 1, j, grid);\rdfs(i, j - 1, grid);\rdfs(i + 1, j, grid);\rdfs(i, j + 1, grid);\r}\rint numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\rfor(unsigned i = 0; i \u0026lt; grid.size(); ++i) {\rfor(unsigned j = 0; j \u0026lt; grid[0].size(); ++j) {\rif(grid[i][j] == \u0026#39;1\u0026#39;) {\rdfs(i, j, grid);\r++count;\r}\r}\r}\rreturn count;\r}\rUnion Find:\rint numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) {\r}\rComplexity Analysis:\r\rTime\rWorst case is O(M X N) where M and N are the dimensions of the input grid.\nMemory\rHere we reuse the input grid which is good. However since it is recursive, its possible to use O(MxN) memory in the case where the grid is all ones.\n",
    "ref": "/hugo/blog/number-of-islands/"
  },{
    "title": "Disjoint Sets",
    "date": "",
    "description": "",
    "body": "Disjoint-set operations\r A disjoint-set data structure maintains a collection S = {s_1, s_2, \u0026hellip; s_k} disjoint sets. We identify each set by a representative.\n Union Pseudocode: \r\rfunction Union(x, y) is\rxRoot := Find(x)\ryRoot := Find(y)\rif xRoot = yRoot then\r// x and y are already in the same set\rreturn\r// x and y are not in same set, so we merge them\rif xRoot.size \u0026lt; yRoot.size then\rxRoot, yRoot := yRoot, xRoot // swap xRoot and yRoot\r// merge yRoot into xRoot\ryRoot.parent := xRoot\rxRoot.size := xRoot.size + yRoot.size\rSet-Union Data Structures:\r\rTodo\nConnected Components DFS Solution:\r\rConnected_Components(Graph G):\rfor v in vertex:\rflag[v] = -1\rcount = 0\rfor v in vertex:\rif flag[v] == -1 // unvisited\r dfs(v, flag)\rcount++\rDFS(int v, int flag) flag[v] = 1\rfor each adjacent node of v\rif flag[u] == - // unvisited\r DFS(u, flag)\rIdea behind connected components DFS.\r\rEvery node is initially marked as -1 meaning not visited.\nThe main loop will go over all verticies, calling a DFS function if that vertex is unvisited ( == -1).\nIf unvisited, a DFS function will be called. This will recursively mark the neighbors of vertex v as visited, and then have then visit their neighbors and so on.\nThis means that when all neighbors have been visited, the DFS call will return. Hence we increment the count.\nAt the end, will will know the number of connected components in the graph.\nComplexity Analysis:\r\r",
    "ref": "/hugo/blog/disjoint-sets/"
  },{
    "title": "129. Sum Root to Leaf Numbers",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/sum-root-to-leaf-numbers/\nProblem Statement:  Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\nAn example is the root-to-leaf path 1-\u0026gt;2-\u0026gt;3 which represents the number 123.\nFind the total sum of all root-to-leaf numbers.\nNote: A leaf is a node with no children.\nExamples  1: Input: [1,2,3] 1 / \\ 2 3 Output: 25 Explanation: The root-to-leaf path 1-\u0026gt;2 represents the number 12. The root-to-leaf path 1-\u0026gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. 2: Input: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 Output: 1026 Explanation: The root-to-leaf path 4-\u0026gt;9-\u0026gt;5 represents the number 495. The root-to-leaf path 4-\u0026gt;9-\u0026gt;1 represents the number 491. The root-to-leaf path 4-\u0026gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Idea:  The idea is traverse our tree, using any tree traversal algorighm. I choose dfs, and also I directly change the values of our tree.\n If we reach non-existing node (None), we just return back. If we reached leaf, that is it do not have any children, return value of this node. Update values for left and right children if they exist. Finally, call function recursively for left and right children and return sum of results for left and right.  Solution:  class Solution { public: void findPath(TreeNode* root, string \u0026amp;path, int \u0026amp;total) { if(root == nullptr) return; path += std::to_string(root-\u0026gt;val); if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { total += stoi(path); } findPath(root-\u0026gt;left, path, total); findPath(root-\u0026gt;right, path, total); path.pop_back(); } int sumNumbers(TreeNode* root) { string path; int total = 0; findPath(root, path, total); return total; } }; TODO: Look at Morris Preorder Traversal.\nComplexity Analysis:  Time O(N). We look at each node once. Memory Here it is O(H) where H is the height of the binary tree. This will be where most recursive calls are made/where path string will be largest. ",
    "ref": "/hugo/blog/sum-root-to-leaf-numbers/"
  },{
    "title": "257. Binary Tree Paths",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/binary-tree-paths/\nProblem Statement:  Given a binary tree, return all root-to-leaf paths.\nNote: A leaf is a node with no children.\nExamples  1: Input: 1 / \\ 2 3 \\ 5 Output: [\u0026#34;1-\u0026gt;2-\u0026gt;5\u0026#34;, \u0026#34;1-\u0026gt;3\u0026#34;] Explanation: All root-to-leaf paths are: 1-\u0026gt;2-\u0026gt;5, 1-\u0026gt;3 Idea:  The most intuitive way is to use a recursion here. One is going through the tree by considering at each step the node itself and its children. If node is not a leaf, one extends the current path by a node value and calls recursively the path construction for its children. If node is a leaf, one closes the current path and adds it into the list of paths.\nSolution:  class Solution { public: void findPath(TreeNode * root, vector\u0026lt;string\u0026gt; \u0026amp;paths, vector\u0026lt;int\u0026gt; \u0026amp;path) { if(root == nullptr) return; path.push_back(root-\u0026gt;val); if(root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { string res = std::to_string(path[0]); for(unsigned i = 1; i \u0026lt; path.size(); ++i) { res += \u0026#34;-\u0026gt;\u0026#34; + std::to_string(path[i]); } paths.push_back(res); } findPath(root-\u0026gt;left, paths, path); findPath(root-\u0026gt;right, paths, path); path.pop_back(); } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode* root) { vector\u0026lt;string\u0026gt; paths; vector\u0026lt;int\u0026gt; path; findPath(root, paths, path); return paths; } }; Complexity Analysis:  Time O(N). We visit each node once. Memory O(N) for the vector of ints reprening the current path. Could be worst case O(N) with unbalanced tree. Expect O(logN) with balanced tree. ",
    "ref": "/hugo/blog/binary-tree-paths/"
  },{
    "title": "814. Binary Tree Pruning",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/binary-tree-pruning/\nProblem Statement:  We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\nExamples  1:   2:   3:   Idea:  The idea here is to make a recursive helper function that will tell us if a given subtree contains a zero. We call this function on the root, and it will be recursively called on the subtrees. If we find at any point a given subtree contains a zero, that branch is effectively removed by setting the subtree to nullptr. At the end, all subtrees that contain zero will be removed.\nSolution:  class Solution { public: bool has_one(TreeNode* root) { if(root == nullptr) return false; bool left = has_one(root-\u0026gt;left); bool right = has_one(root-\u0026gt;right); if(!left) root-\u0026gt;left = nullptr; if(!right) root-\u0026gt;right = nullptr; return left || right || root-\u0026gt;val == 1; } TreeNode* pruneTree(TreeNode* root) { return has_one(root) ? root: nullptr; } }; Complexity Analysis:  Time Time Complexity here is O(N). We process each node once in the process. Memory Here space compexity is O(H) where H is the height of our tree. In the worst case, we expect order O(N) for a totally unbalanced tree. Expect O(logN) if working with balanced tree.",
    "ref": "/hugo/blog/binary-tree-pruning/"
  },{
    "title": "235. Lowest Common Ancestor of a Binary Search Tree",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\nProblem Statement:  Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: ‚ÄúThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).‚Äù\nExample:  Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Idea:  My approach was recursive in nature, but prunes the tree and can achieve O(log N) time and space complexity (call stack) if used on a balanced tree.\nThe idea is to check if p and q are in different subtrees. If p is on the left and q is on the right, or vice versa, this means that we have found the solution. The first node in which p and q are in different trees is by definition their least common ancestor.\nTherefore, we use the sorted nature of the BST to go left or right if p and q are on the same side of the tree. If they aren\u0026rsquo;t on the same side, we\u0026rsquo;ve found the solution.\nIf we never find such a node, return nullptr;\nAs a side note, I chose to make p and q global to avoid passing them along the call stack in the recursive function.\nSolution:  class Solution { public: int PVAL, QVAL; TreeNode* findLCA(TreeNode* root) { if(!root) return nullptr; if((PVAL \u0026gt;= root-\u0026gt;val \u0026amp;\u0026amp; QVAL \u0026lt;= root-\u0026gt;val) || (PVAL \u0026lt;= root-\u0026gt;val \u0026amp;\u0026amp; QVAL \u0026gt;= root-\u0026gt;val)) { return root; } if(PVAL \u0026gt; root-\u0026gt;val) { return findLCA(root-\u0026gt;right); } else { return findLCA(root-\u0026gt;left); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { PVAL = p-\u0026gt;val; QVAL = q-\u0026gt;val; return findLCA(root); } }; Complexity Analysis:  Time Here worst case is O(N) if our tree is an unbalanced stick where p/q happen to be very far from the root.\nWith idea situations, search space is cut in half each time provided the tree is balanced so we see O(logN) time complexity.\nComplexity is directly related to the ability so find the solution.\nMemory Memory usage is directly related to the number of stack frames for recursive search. O(N) unbalanced stick with p \u0026amp; q far from root. O(logN) with balanced tree.\n",
    "ref": "/hugo/blog/lowest-common-ancestor-bst/"
  },{
    "title": "100. Same Tree",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/same-tree/\nGiven two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\nIdea:\rRecursively check each node in each tree. If both are null, we\u0026rsquo;ve gone off the end so return true If one is null and the other isn\u0026rsquo;t, there is a difference. If one has a val that isn\u0026rsquo;t equal to the other, there is a difference. Otherwise recursively call on the subtrees.\nSolution:\rclass solution {\rpublic:\rbool issametree(treenode* p, treenode* q) {\rif(!p and !q) return true;\rif(!p or !q) return false;\rif(p-\u0026gt;val != q-\u0026gt;val) return false;\rreturn issametree(p-\u0026gt;left, q-\u0026gt;left) \u0026amp;\u0026amp; issametree(p-\u0026gt;right, q-\u0026gt;right);\r}\r};\rComplexity Analysis:\r\rTime\rO(N). Each node in each tree compared.\rMemory\rO(N). Worst case stack usage if trees are unbalanced.",
    "ref": "/hugo/blog/same-tree/"
  },{
    "title": "113. Path Sum II",
    "date": "",
    "description": "",
    "body": "https://leetcode.com/problems/path-sum-ii/\nProblem Statement:  Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children.\nExample:  Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return:\n[ [5,4,11,2], [5,8,4,5] ] Idea:  We can solve this using a recursive depth first search approach. First we set up a helper function that will help us recursively store the path and add it if a matching sum is found. As base cases, our recursive function will return if the node is null, or a leaf node matching the sum has been found.\nOtherwise, the function is called recursively on the left and right subtrees.\nAt the end, the results list with all such paths is returned.\nSolution:  class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int sum) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; paths; vector\u0026lt;int\u0026gt; path; findPaths(root, sum, path, paths); return paths; } private: void findPaths(TreeNode* node, int sum, vector\u0026lt;int\u0026gt;\u0026amp; path, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; paths) { if (!node) return; path.push_back(node -\u0026gt; val); if (!(node -\u0026gt; left) \u0026amp;\u0026amp; !(node -\u0026gt; right) \u0026amp;\u0026amp; sum == node -\u0026gt; val) paths.push_back(path); findPaths(node -\u0026gt; left, sum - node -\u0026gt; val, path, paths); findPaths(node -\u0026gt; right, sum - node -\u0026gt; val, path, paths); path.pop_back(); } }; Complexity Analysis:  Time O(N^2) where N is the number of nodes in a tree. In the worst case, we could have a complete binary tree and if that is the case, then there would be N/2 leafs. For every leaf, we perform a potential O(N) operation of copying over the pathNodes nodes to a new list to be added to the final pathsList. Hence, the complexity in the worst case could be O(N^2). Memory O(N). From Leetcode discussion - The space complexity, like many other problems is debatable here. I personally choose not to consider the space occupied by the output in the space complexity. So, all the new lists that we create for the paths are actually a part of the output and hence, don't count towards the final space complexity. The only additional space that we use is the pathNodes list to keep track of nodes along a branch. We could include the space occupied by the new lists (and hence the output) in the space complexity and in that case the space would be O(N^2) There\u0026rsquo;s a great answer on Stack Overflow about whether to consider input and output space in the space complexity or not. I prefer not to include them.\n",
    "ref": "/hugo/blog/path-sum-ii/"
  },{
    "title": "About",
    "date": "",
    "description": "",
    "body": "Todo\n",
    "ref": "/hugo/about/"
  },{
    "title": "Emoji Support",
    "date": "",
    "description": "Guide to emoji usage in Hugo",
    "body": "Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site‚Äôs configuration and then you can type emoji shorthand codes directly in content files; e.g.\nüôà :see_no_evil: üôâ :hear_no_evil: üôä :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }",
    "ref": "/hugo/blog/emoji-support/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/hugo/contact/"
  }]
