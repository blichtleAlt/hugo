<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>medium on Brendan&#39;s Blog</title>
    <link>https://blichtlealt.github.io/hugo/tags/medium/</link>
    <description>Recent content in medium on Brendan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 22 Nov 2022 19:50:39 -0800</lastBuildDate><atom:link href="https://blichtlealt.github.io/hugo/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>981. Time Based Key-Value Store</title>
      <link>https://blichtlealt.github.io/hugo/blog/time-based-key-value-store/</link>
      <pubDate>Tue, 22 Nov 2022 19:50:39 -0800</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/time-based-key-value-store/</guid>
      <description>https://leetcode.com/problems/time-based-key-value-store/
Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&amp;rsquo;s value at a certain timestamp.
Implement the TimeMap class:
TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &amp;lt;= timestamp.</description>
    </item>
    
    <item>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link>https://blichtlealt.github.io/hugo/blog/reverse-polish-notation/</link>
      <pubDate>Mon, 21 Nov 2022 20:06:39 -0800</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/reverse-polish-notation/</guid>
      <description>https://leetcode.com/problems/evaluate-reverse-polish-notation/
Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, and /. Each operand may be an integer or another expression.
Note that division between two integers should truncate toward zero.
It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</description>
    </item>
    
    <item>
      <title>79. Word Search</title>
      <link>https://blichtlealt.github.io/hugo/blog/word-search/</link>
      <pubDate>Sat, 21 Aug 2021 17:21:49 -0700</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/word-search/</guid>
      <description>https://leetcode.com/problems/word-search/
Problem Statement:Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
 Examples1: Input: board = [[&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;E&amp;#34;],[&amp;#34;S&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;S&amp;#34;],[&amp;#34;A&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;E&amp;#34;]], word = &amp;#34;ABCCED&amp;#34;Output: true Idea:Here what we do is a breadth first search, but also marking our path as we going along.</description>
    </item>
    
    <item>
      <title>55. Jump Game</title>
      <link>https://blichtlealt.github.io/hugo/blog/jump_game/</link>
      <pubDate>Wed, 23 Dec 2020 04:05:17 -0500</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/jump_game/</guid>
      <description>https://leetcode.com/problems/jump-game/
Problem Statement: Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.
ExamplesExample 1Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>994. Rotting Oranges</title>
      <link>https://blichtlealt.github.io/hugo/blog/rotting-oranges/</link>
      <pubDate>Mon, 17 Aug 2020 18:14:12 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/rotting-oranges/</guid>
      <description>https://leetcode.com/problems/rotting-oranges/
Problem Statement: In a given grid, each cell can have one of three values:
the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.
Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://blichtlealt.github.io/hugo/blog/number-of-islands/</link>
      <pubDate>Wed, 12 Aug 2020 23:17:44 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/number-of-islands/</guid>
      <description>https://leetcode.com/problems/number-of-islands/solution/
Problem Statement: Given a 2d grid map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Examples1: Input: grid = [  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 1 2: Input: grid = [  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],  [&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;] ] Output: 3 Idea:This question is analogous to the problem of connected components in an undirected graph.</description>
    </item>
    
    <item>
      <title>129. Sum Root to Leaf Numbers</title>
      <link>https://blichtlealt.github.io/hugo/blog/sum-root-to-leaf-numbers/</link>
      <pubDate>Mon, 10 Aug 2020 23:55:08 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/sum-root-to-leaf-numbers/</guid>
      <description>https://leetcode.com/problems/sum-root-to-leaf-numbers/
Problem Statement:  Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1-&amp;gt;2-&amp;gt;3 which represents the number 123.
Find the total sum of all root-to-leaf numbers.
Note: A leaf is a node with no children.
Examples  1: Input: [1,2,3]  1  / \  2 3 Output: 25 Explanation: The root-to-leaf path 1-&amp;gt;2 represents the number 12.</description>
    </item>
    
    <item>
      <title>814. Binary Tree Pruning</title>
      <link>https://blichtlealt.github.io/hugo/blog/binary-tree-pruning/</link>
      <pubDate>Mon, 10 Aug 2020 17:46:40 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/binary-tree-pruning/</guid>
      <description>https://leetcode.com/problems/binary-tree-pruning/
Problem Statement:  We are given the head node root of a binary tree, where additionally every node&#39;s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)
Examples  1:   2:   3:   Idea:  The idea here is to make a recursive helper function that will tell us if a given subtree contains a zero.</description>
    </item>
    
    <item>
      <title>113. Path Sum II</title>
      <link>https://blichtlealt.github.io/hugo/blog/path-sum-ii/</link>
      <pubDate>Mon, 10 Aug 2020 00:55:08 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/path-sum-ii/</guid>
      <description>https://leetcode.com/problems/path-sum-ii/
Problem Statement:  Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum. Note: A leaf is a node with no children.
Example:  Given the below binary tree and sum = 22,  5  / \  4 8  / / \  11 13 4  / \ / \ 7 2 5 1 Return:
[  [5,4,11,2],  [5,8,4,5] ] Idea:  We can solve this using a recursive depth first search approach.</description>
    </item>
    
  </channel>
</rss>
