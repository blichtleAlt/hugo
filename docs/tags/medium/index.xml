<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>medium on Brendan&#39;s Blog</title>
    <link>https://blichtlealt.github.io/hugo/tags/medium/</link>
    <description>Recent content in medium on Brendan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 22 Dec 2020 21:41:48 -0500</lastBuildDate>
    
	<atom:link href="https://blichtlealt.github.io/hugo/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Count_one_bits</title>
      <link>https://blichtlealt.github.io/hugo/blog/count_one_bits/</link>
      <pubDate>Tue, 22 Dec 2020 21:41:48 -0500</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/count_one_bits/</guid>
      <description>TODO: Link
Problem Statement: Examples1: 2: 3: Idea:Solution:Complexity Analysis:TimeMemory</description>
    </item>
    
    <item>
      <title>994. Rotting Oranges</title>
      <link>https://blichtlealt.github.io/hugo/blog/rotting-oranges/</link>
      <pubDate>Mon, 17 Aug 2020 18:14:12 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/rotting-oranges/</guid>
      <description>https://leetcode.com/problems/rotting-oranges/
Problem Statement: In a given grid, each cell can have one of three values:
the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.
Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.</description>
    </item>
    
    <item>
      <title>200. Number of Islands</title>
      <link>https://blichtlealt.github.io/hugo/blog/number-of-islands/</link>
      <pubDate>Wed, 12 Aug 2020 23:17:44 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/number-of-islands/</guid>
      <description>https://leetcode.com/problems/number-of-islands/solution/
Problem Statement: Given a 2d grid map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Examples1:Input: grid = [[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;]]Output: 12:Input: grid = [[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;],[&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;]]Output: 3Idea:This question is analogous to the problem of connected components in an undirected graph.</description>
    </item>
    
    <item>
      <title>129. Sum Root to Leaf Numbers</title>
      <link>https://blichtlealt.github.io/hugo/blog/sum-root-to-leaf-numbers/</link>
      <pubDate>Mon, 10 Aug 2020 23:55:08 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/sum-root-to-leaf-numbers/</guid>
      <description>https://leetcode.com/problems/sum-root-to-leaf-numbers/
Problem Statement:  Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1-&amp;gt;2-&amp;gt;3 which represents the number 123.
Find the total sum of all root-to-leaf numbers.
Note: A leaf is a node with no children.
Examples  1: Input: [1,2,3] 1 / \ 2 3 Output: 25 Explanation: The root-to-leaf path 1-&amp;gt;2 represents the number 12. The root-to-leaf path 1-&amp;gt;3 represents the number 13.</description>
    </item>
    
    <item>
      <title>814. Binary Tree Pruning</title>
      <link>https://blichtlealt.github.io/hugo/blog/binary-tree-pruning/</link>
      <pubDate>Mon, 10 Aug 2020 17:46:40 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/binary-tree-pruning/</guid>
      <description>https://leetcode.com/problems/binary-tree-pruning/
Problem Statement:  We are given the head node root of a binary tree, where additionally every node&#39;s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.
(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)
Examples  1:   2:   3:   Idea:  The idea here is to make a recursive helper function that will tell us if a given subtree contains a zero.</description>
    </item>
    
    <item>
      <title>113. Path Sum II</title>
      <link>https://blichtlealt.github.io/hugo/blog/path-sum-ii/</link>
      <pubDate>Mon, 10 Aug 2020 00:55:08 -0400</pubDate>
      
      <guid>https://blichtlealt.github.io/hugo/blog/path-sum-ii/</guid>
      <description>https://leetcode.com/problems/path-sum-ii/
Problem Statement:  Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum. Note: A leaf is a node with no children.
Example:  Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return:
[ [5,4,11,2], [5,8,4,5] ] Idea:  We can solve this using a recursive depth first search approach.</description>
    </item>
    
  </channel>
</rss>